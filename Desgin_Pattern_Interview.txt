Design Pattern
----------------
The singleton pattern is one of the simplest design patterns. Sometimes we need to have only one instance of our class for example a single DB connection shared by 
multiple objects as creating a separate DB connection for every object may be costly. Similarly, there can be a single configuration manager or error manager in an 
application that handles all problems instead of creating multiple managers.

Singlton Design Pattern:- The singleton pattern is a design pattern that restricts the instantiation of a class to one object. 


Example 1:-
// Classical Java implementation of singleton
// design pattern
class Singleton
{




	private static Singleton obj;

	// private constructor to force use of
	// getInstance() to create Singleton object
	private Singleton() {}

	public static Singleton getInstance()
	{
		if (obj==null)
			obj = new Singleton();
		return obj;
	}
}



Method 2 we make syncronized method for executing in multithreding Enviroment

// Thread Synchronized Java implementation of
// singleton design pattern
class Singleton
{
	private static Singleton obj;

	private Singleton() {}

	// Only one thread can execute this at a time
	public static synchronized Singleton getInstance()
	{
		if (obj==null)
			obj = new Singleton();
		return obj;
	}
}

Method 3: Eager Instantiation 

Here we have created instance of singleton in static initializer. JVM executes static initializer when the class is loaded and hence
this is guaranteed to be thread safe. Use this method only when your singleton class is light and is used throughout the execution of your program.


// Static initializer based Java implementation of
// singleton design pattern
class Singleton
{
	private static Singleton obj = new Singleton();

	private Singleton() {}

	public static Singleton getInstance()
	{
		return obj;
	}

}



Method 4 (Best): Use “Double Checked Locking” 
If you notice carefully once an object is created synchronization is no longer useful because now obj will not be null and any sequence of operations will lead
 to consistent results. So we will only acquire lock on the getInstance() once, when the obj is null. This way we only synchronize the first way through, just what
 we want.

// Double Checked Locking based Java implementation of
// singleton design pattern
class Singleton
{
	private static volatile Singleton obj = null;

	private Singleton() {}

	public static Singleton getInstance()
	{
		if (obj == null)
		{
			// To make thread safe
			synchronized (Singleton.class)
			{
				// check again as multiple threads
				// can reach above step
				if (obj==null)
					obj = new Singleton();
			}
		}
		return obj;
	}
}
